// ChannelBoxPluginV2 export DCTL

__DEVICE__ float3 transform(int p_Width, int p_Height, int p_X, int p_Y, float p_R, float p_G, float p_B)
{
    
		// switches for display matte, invert alpha
		int displaymatte = 0;
		bool DisplayMatte = displaymatte == 1;
		int invertalpha = 0;
		bool InvertAlpha = invertalpha == 1;

		// channel combinations
		int bluered = 1;
		int bluegreen = 0;
		int bluegreenred = 0;
		int bluemxgreenred = 0;
		
		int greenred = 0;
		int greenblue = 0;
		int greenbluered = 0;
		int greenmxbluered = 0;
		
		int redgreen = 0;
		int redblue = 0;
		int redbluegreen = 0;
		int redmxbluegreen = 0;
		
		bool BlueRed = bluered == 1;
		bool BlueGreen = bluegreen == 1;
		bool BlueGreenRed = bluegreenred == 1;
		bool BlueMxGreenRed = bluemxgreenred == 1;
		
		bool GreenRed = greenred == 1;
		bool GreenBlue = greenblue == 1;
		bool GreenBlueRed = greenbluered == 1;
		bool GreenMxBlueRed = greenmxbluered == 1;
		
		bool RedGreen = redgreen == 1;
		bool RedBlue = redblue == 1;
		bool RedBlueGreen = redbluegreen == 1;
		bool RedMxBlueGreen = redmxbluegreen == 1;

		// matte parameter values
		float high = 1.0f;
		float highfade = 1.0f;
		float lowfade = 1.0f;
		float low = 0.0f;
		float highfadecurve = 1.0f;
		float lowfadecurve = 1.0f;
		float offset = 0.0f;
		float mix = 0.0f;

     
		float luma = (p_R * 0.2126f) + (p_G * 0.7152f) + (p_B * 0.0722f);  
		float L = luma - offset;								
		float q = _fminf(L, 1.0f);									
		float n = _fmaxf(q, 0.0f);

		float BR = p_B > p_R ? p_R : p_B;    
		float BG = p_B > p_G ? p_G : p_B;    
		float BGR = p_B > _fminf(p_G, p_R) ? _fminf(p_G, p_R) : p_B;    
		float BGRX = p_B > _fmaxf(p_G, p_R) ? _fmaxf(p_G, p_R) : p_B;    
		float blue = BlueRed ? BR : (BlueGreen ? BG : (BlueGreenRed ? BGR : (BlueMxGreenRed ? BGRX : p_B))); 
													
		float GR = p_G > p_R ? p_R : p_G;    
		float GB = p_G > p_B ? p_B : p_G;    
		float GBR = p_G > _fminf(p_B, p_R) ? _fminf(p_B, p_R) : p_G;    
		float GBRX = p_G > _fmaxf(p_B, p_R) ? _fmaxf(p_B, p_R) : p_G;    
		float green = GreenRed ? GR : (GreenBlue ? GB : (GreenBlueRed ? GBR : (GreenMxBlueRed ? GBRX : p_G))); 
													
		float RG = p_R > p_G ? p_G : p_R;    
		float RB = p_R > p_B ? p_B : p_R;    
		float RBG = p_R > _fminf(p_B, p_G) ? _fminf(p_B, p_G) : p_R;    
		float RBGX = p_R > _fmaxf(p_B, p_G) ? _fmaxf(p_B, p_G) : p_R;    
		float red = RedGreen ? RG : (RedBlue ? RB : (RedBlueGreen ? RBG : (RedMxBlueGreen ? RBGX : p_R))); 					
													 		 

		float highalpha = high + n == 0.0f ? 0.0f : high - (1.0f - highfade) >= n ? 1.0f : (high >= n ? _powf((high - n) / (1.0f - highfade), highfadecurve) : 0.0f);
		float lowalpha = low + n == 2.0f ? 0.0f : low + lowfade <= n ? 1.0f : (low <= n ? _powf((n - low) / lowfade, lowfadecurve) : 0.0f);
		float alpha = highalpha * lowalpha;
		float alphaM = alpha + (1.0f - alpha) * mix;
		float alphaV = InvertAlpha ? 1.0f - alphaM : alphaM;
																									
		float r = DisplayMatte ? alphaV : p_R * (1.0f - alphaV) + (red * alphaV);		
		float g = DisplayMatte ? alphaV : p_G * (1.0f - alphaV) + (green * alphaV);
		float b = DisplayMatte ? alphaV : p_B * (1.0f - alphaV) + (blue * alphaV);

		return make_float3(r, g, b);
}
