// QualifierPluginV2 export DCTL

__DEVICE__ float3 transform(int p_Width, int p_Height, int p_X, int p_Y, float p_R, float p_G, float p_B)
{
    
    // switches for display matte, invert main alpha
	int displaymatte = 1;
	bool DisplayMatte = displaymatte == 1;
	int maininvertalpha = 0;
	bool MainInvertAlpha = maininvertalpha == 1;

	// switches for luma matte enable, invert alpha
	int lumamatte = 1;
	bool LumaMatte = lumamatte == 1;
	int lumainvertalpha = 0;
	bool LumaInvertAlpha = lumainvertalpha == 1;

	// switches for saturation matte enable, invert alpha
	int satmatte = 1;
	bool SatMatte = satmatte == 1;
	int satinvertalpha = 0;
	bool SatInvertAlpha = satinvertalpha == 1;

	// switches for hue matte enable, invert alpha
	int huematte = 1;
	bool HueMatte = huematte == 1;
	int hueinvertalpha = 0;
	bool HueInvertAlpha = hueinvertalpha == 1;

    
    float luma = (p_R * 0.2126f) + (p_G * 0.7152f) + (p_B * 0.0722f);
    float lm = _fminf(luma, 1.0f);									
    float L = _fmaxf(lm, 0.0f);
    
    float Mx = _fmaxf(p_R, _fmaxf(p_G, p_B));				
	float mn = _fminf(p_R, _fminf(p_G, p_B));	 		
	float del_Max = Mx - mn;
												
	float Ls = 0.5f * (Mx + mn);													
	float S = del_Max == 0.0f ? 0.0f : del_Max / (1.0f - (2.0f * Ls - 1.0f));
	
	float del_R = (((Mx - p_R) / 6.0f) + (del_Max / 2.0f)) / del_Max;
    float del_G = (((Mx - p_G) / 6.0f) + (del_Max / 2.0f)) / del_Max;
    float del_B = (((Mx - p_B) / 6.0f) + (del_Max / 2.0f)) / del_Max;
    
    float h = del_Max == 0.0f ? 0.0f : (p_R == Mx ? del_B - del_G : (p_G == Mx ? 
    (1.0f / 3.0f) + del_R - del_B : (2.0f / 3.0f) + del_G - del_R));
    
    // luma matte parameter values
	float lumahigh = 1.0f;
	float lumahighfade = 1.0f;
	float lumalowfade = 1.0f;
	float lumalow = 0.0f;
	float lumahighfadecurve = 1.0f;
	float lumalowfadecurve = 1.0f;
	
	float lumahighalpha = lumahigh + L == 0.0f ? 0.0f : lumahigh - (1.0f - lumahighfade) >= L ? 1.0f : (lumahigh >= L ? _powf((lumahigh - L) / (1.0f - lumahighfade), lumahighfadecurve) : 0.0f);
	float lumalowalpha = lumalow + L == 2.0f ? 0.0f : lumalow + lumalowfade <= L ? 1.0f : (lumalow <= L ? _powf((L - lumalow) / lumalowfade, lumalowfadecurve) : 0.0f);
	float alphal = lumahighalpha * lumalowalpha;
	float alphall = LumaInvertAlpha ? 1.0f - alphal : alphal;		
    float alphaLuma = LumaMatte ? alphall : 1.0f;
	
	// saturation matte parameter values
	float sathigh = 1.0f;
	float sathighfade = 1.0f;
	float satlowfade = 0.0f;
	float satlow = 0.0f;
	float sathighfadecurve = 1.0f;
	float satlowfadecurve = 1.0f;
	
	float sathighalpha = sathigh + S == 0.0f ? 0.0f : sathigh - (1.0f - sathighfade) >= S ? 1.0f : (sathigh >= S ? _powf((sathigh - S) / (1.0f - sathighfade), sathighfadecurve) : 0.0f);
	float satlowalpha = satlow + S == 2.0f ? 0.0f : satlow + satlowfade <= S ? 1.0f : (satlow <= S ? _powf((S - satlow) / satlowfade, satlowfadecurve) : 0.0f);
	float alphas = sathighalpha * satlowalpha;
	float alphass = SatInvertAlpha ? 1.0f - alphas : alphas;		
    float alphaSat = SatMatte ? alphass : 1.0f;
    
    // hue matte parameter values
	float huehigh = 1.0f;
	float huehighfade = 1.0f;
	float huelowfade = 0.0f;
	float huelow = 0.0f;
	float huehighfadecurve = 1.0f;
	float huelowfadecurve = 1.0f;
	float hueoffset = 0.0f * -1.0f;
	
	float Ha = h == 0.0f ? 0.0f : (h + hueoffset > 1.0f ? h + hueoffset - 1.0f : (h + hueoffset < 0.0f ? h + hueoffset + 1.0f : h + hueoffset));
    float H = (huehigh == 1.0f) && (huehighfade == 1.0f) && (huelowfade == 0.0f) && (huelow == 0.0f) ? 1.0f : Ha;
	
	float huehighalpha = huehigh + H == 0.0f ? 0.0f : huehigh - (1.0f - huehighfade) >= H ? 1.0f : (huehigh >= H ? _powf((huehigh - H) / (1.0f - huehighfade), huehighfadecurve) : 0.0f);
	float huelowalpha = huelow + H == 2.0f ? 0.0f : huelow + huelowfade <= H ? 1.0f : (huelow <= H ? _powf((H - huelow) / huelowfade, huelowfadecurve) : 0.0f);
	float alphah = huehighalpha * huelowalpha;
	float alphahh = HueInvertAlpha ? 1.0f - alphah : alphah;		
    float alphaHue = HueMatte ? alphahh : 1.0f;
    
	float MIX = 0.0f;	
								
	float alphaLSH = (alphaLuma * alphaSat) * alphaHue;				
	float alphav = alphaLSH + (1.0f - alphaLSH) * MIX;				
	float alphaV = MainInvertAlpha ? (1.0 - alphav) : alphav;
	
	float r = DisplayMatte ? alphaV : p_R;
	float g = DisplayMatte ? alphaV : p_G;
	float b = DisplayMatte ? alphaV : p_B;

    return make_float3(r, g, b);
}
